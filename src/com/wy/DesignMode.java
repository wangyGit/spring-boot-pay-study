package com.wy;

public class DesignMode {

    /**
     * 设计模式：
     *      相应原则：
     *      1.开闭原则 ：
     *      2.里式替换 ：
     *      3.依赖倒置原则：
     *      4.单一职责原则：
     *      5.接口隔离原则：
     *      6.迪米特原则 ：
     *      7.合成复用原则：
     */

    /*单例（Singleton）模式的定义：
    指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个
    任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。
    在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、
    应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。
    */


    /***
     * 原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。
     */


    /*工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。
    这满足创建型模式中所要求的“创建与使用相分离”的特点。
    注意：简单工厂模式不属于23种设计模式之一，因为在增加新产品时违背开闭原则.

    工厂方法模式的主要优点有：
    1.主要利于代码的解耦，把对象的创建和使用工程分开。
    2.工厂模式可以降低代码重复，如果创建B对象的过程很复杂，需要一定的代码量，而且很多地方需要使用到，我们可以这些创建对象B的
    代码放到工厂里统一管理。
    用户只需要知道具得到所要的产品，无须知道产品的具体创建过程；
    在系统增加新的产品时只体现工厂的名称就可需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；
    其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。
    应用场景：1. hibernate里通过sessionFactory创建session
             2.数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时

    简单工厂：就是把抽象工厂剔除掉。
    */


    /***
     * 抽象工厂模式：
     * 抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 java 的 AWT 中的 Button 和 Text 等构件在 Windows 和
     * UNIX 中的本地实现是不同的。
     *
     * 抽象工厂模式通常适用于以下场景：
     * 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
     * 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
     * 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。
     */


    /***
     * 建造者模式：
     * 优缺点
     * 先说说优点
     * 首先是易于解耦，将产品本身与产品创建过程进行解耦，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。
     * 其次易于精确控制对象的创建，将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰
     * 最后是易于拓展，增加新的具体建造者无需修改原有类库的代码，易于拓展，符合“开闭原则“。
     * 缺点方面
     * 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使
     * 用范围受到一定的限制；如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。
     *
     * 应用场景:
     * 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。
     * 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。
     * /

     /*
       代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，
       代理对象作为访问对象和目标对象之间的中介。
       抽象类、具体类、代理类。

     应用场景：
     静态代理：优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。
              缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。
     动态代理：
     远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的
     文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。
     虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法
     完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。
     安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
     智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被
     引用时，就可以自动释放它。
     延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。
     */












    }

